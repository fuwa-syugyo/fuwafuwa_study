## クイックスタート

### state

コンポーネントに情報を記憶させたいときに使う。
`import { useState } from 'react';` でコンポーネント内で`state`変数を宣言できるようになる。

`useState`からは現在のstate(`count`)と、それを更新するための関数(`setCount`)の2つが得られる。
`const [count, setCount] = useState(0);`のように「`hoge`と`setHoge`」のような組み合わせの名前で記述する。
stateを変更したいときに`setCount()`を呼び出して新しい値を渡す。

### フック

`use~`で始まる関数のこと。`useState`とか。
組み込みのフック以外にも、組み合わせて自分だけのカスタムフックを作ることもできる。
ここでは組み込みフックを紹介。

**stateフック**

ユーザー入力などの情報をコンポーネントに記憶させることができる。↑で説明しているので略。
`useState`: 直接的に更新できるstate変数を定義する。
`useReducer`: リデューサ関数(何?)内に書いたロジックを用いて更新を行うstate変数を定義する。

**コンテクストフック**

propsを渡すことなく、離れた親要素から情報を取得できるようにするフック。
例えば、アプリの最上位コンポーネントが現在のUIテーマをすべてのコンポーネントに渡すことができるとか。
`useContext`: コンテクストの値を読み取り、変更を受け取れるようにする。

**refフック**

コンポーネントがDOMノードやタイムアウトIDなどの、レンダーに用いない情報を保持することができる。
stateとの違いはrefの値を更新してもコンポーネントが再レンダーされないこと。
Reactパラダイムからの「避難ハッチ」らしい。(どういうこと？)
`useRef`: refを宣言する。だいたいDOMノードを格納するために使われる。

**エフェクトフック**

コンポーネントを外部システムに接続し、同期させることができる。
ネットワーク、ブラウザのDOM、アニメーションや、非Reactコードの処理が含まれる。
`useEffect`: 外部システムとコンポーネントを接続する。

**パフォーマンス関連フック**

不要な処理を減らす。
例えば、キャッシュ済みの計算結果の再利用や、データの変更がない場合の再レンダーをスキップするようにReactに伝える。
`useMemo`: 高負荷な計算結果をキャッシュできる。
`useCallback`: 最適化済みのコンポーネントに渡すために関数定義をキャッシュする。
`useTransition`: stateの遷移をノンブロッキングなものとしてマークして、他の更新による割り込みを許可する。
`useDeferredValue`: UIの重要ではない部分の更新を遅延させ、他の部分を優先的に更新させる。
